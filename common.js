// Generated by CoffeeScript 1.6.3
(function() {
  (function(undefined_) {
    var cleanSep, forEach, isArray, isArrayLike, isFunction, isString, isWindow, namespace, sumRows, transposeMtx, trim;
    namespace = "od2vcommon";
    if (typeof window !== "undefined") {
      this[namespace] = window[namespace] = window[namespace] || {};
    }
    if (typeof module !== "undefined") {
      this[namespace] = module.exports = {};
    }
    isFunction = function(value) {
      return typeof value === "function";
    };
    isString = function(value) {
      return typeof value === "string";
    };
    isWindow = function(obj) {
      return obj && obj.document && obj.location && obj.alert && obj.setInterval;
    };
    isArray = function(value) {
      return toString.call(value) === "[object Array]";
    };
    isArrayLike = function(obj) {
      var length;
      if ((obj == null) || isWindow(obj)) {
        return false;
      }
      length = obj.length;
      if (obj.nodeType === 1 && length) {
        return true;
      }
      return isString(obj) || isArray(obj) || length === 0 || typeof length === "number" && length > 0 && (length - 1) in obj;
    };
    forEach = function(obj, iterator, context) {
      var key, _results, _results1, _results2;
      if (!obj) {
        obj;
      }
      if (isFunction(obj)) {
        _results = [];
        for (key in obj) {
          if (key !== "prototype" && key !== "length" && key !== "name" && (!obj.hasOwnProperty || obj.hasOwnProperty(key))) {
            _results.push(iterator.call(context, obj[key], key));
          } else {
            _results.push(void 0);
          }
        }
        return _results;
      } else if (obj.forEach && obj.forEach !== forEach) {
        return obj.forEach(iterator, context);
      } else if (isArrayLike(obj)) {
        key = 0;
        _results1 = [];
        while (key < obj.length) {
          iterator.call(context, obj[key], key);
          _results1.push(key++);
        }
        return _results1;
      } else {
        _results2 = [];
        for (key in obj) {
          if (obj.hasOwnProperty(key)) {
            _results2.push(iterator.call(context, obj[key], key));
          } else {
            _results2.push(void 0);
          }
        }
        return _results2;
      }
    };
    trim = function(str) {
      if (typeof str !== "string") {
        return str;
      }
      return str.replace(new RegExp(/^\s+|\s+$/g), "");
    };
    cleanSep = function(str) {
      if (typeof str !== "string") {
        return str;
      }
      return trim(str.substring(str.indexOf(":") + 1));
    };
    transposeMtx = function(mtx) {
      var transpose;
      transpose = [new Array(mtx.length)];
      forEach(mtx, function(row, i) {
        return forEach(row, function(col, j) {
          if (transpose[j] == null) {
            transpose[j] = [];
          }
          return transpose[j][i] = mtx[i][j];
        });
      });
      return transpose;
    };
    sumRows = function(mtx, dest) {
      return forEach(mtx, function(row) {
        var sum;
        sum = 0;
        forEach(row, (function(col, idx) {
          if (!isNaN(Number(col))) {
            return sum += col;
          }
        }), sum);
        if (!dest) {
          return row.push(sum);
        } else {
          return dest.push(sum);
        }
      });
    };
    this[namespace].forEach = forEach;
    this[namespace].trim = trim;
    this[namespace].cleanSep = cleanSep;
    this[namespace].transposeMtx = transposeMtx;
    this[namespace].isArray = isArray;
    this[namespace].isString = isString;
    return this[namespace].sumRows = sumRows;
  })();

}).call(this);