// Generated by CoffeeScript 1.4.0
(function() {

  (function(undefined_) {
    var cleanSep, extractTables, forEach, isArray, isArrayLike, isFunction, isIndexTable, isString, isWindow, namespace, removeTotal, transposeMtx, trim;
    namespace = "od2v";
    if (typeof window !== "undefined") {
      this[namespace] = window[namespace] = window[namespace] || {};
    }
    if (typeof module !== "undefined") {
      this[namespace] = module.exports = {};
    }
    isFunction = function(value) {
      return typeof value === "function";
    };
    isString = function(value) {
      return typeof value === "string";
    };
    isWindow = function(obj) {
      return obj && obj.document && obj.location && obj.alert && obj.setInterval;
    };
    isArray = function(value) {
      return toString.call(value) === "[object Array]";
    };
    isArrayLike = function(obj) {
      var length;
      if (!(obj != null) || isWindow(obj)) {
        return false;
      }
      length = obj.length;
      if (obj.nodeType === 1 && length) {
        return true;
      }
      return isString(obj) || isArray(obj) || length === 0 || typeof length === "number" && length > 0 && (length - 1) in obj;
    };
    forEach = function(obj, iterator, context) {
      var key, _results, _results1, _results2;
      if (!obj) {
        obj;

      }
      if (isFunction(obj)) {
        _results = [];
        for (key in obj) {
          if (key !== "prototype" && key !== "length" && key !== "name" && (!obj.hasOwnProperty || obj.hasOwnProperty(key))) {
            _results.push(iterator.call(context, obj[key], key));
          } else {
            _results.push(void 0);
          }
        }
        return _results;
      } else if (obj.forEach && obj.forEach !== forEach) {
        return obj.forEach(iterator, context);
      } else if (isArrayLike(obj)) {
        key = 0;
        _results1 = [];
        while (key < obj.length) {
          iterator.call(context, obj[key], key);
          _results1.push(key++);
        }
        return _results1;
      } else {
        _results2 = [];
        for (key in obj) {
          if (obj.hasOwnProperty(key)) {
            _results2.push(iterator.call(context, obj[key], key));
          } else {
            _results2.push(void 0);
          }
        }
        return _results2;
      }
    };
    trim = function(str) {
      if (typeof str !== "string") {
        return str;
      }
      return str.replace(new RegExp(/^\s+|\s+$/g), "");
    };
    cleanSep = function(str) {
      return trim(str.substring(str.indexOf(":") + 1));
    };
    isIndexTable = function(table) {
      return table.dim[0] && table.dat && table.dim[0].length === table.dat.length && table.dim[1] && table.dat[0] && table.dim[1].length === table.dat[0].length;
    };
    removeTotal = function(mtx) {
      var i, j, k, sortarr, sum;
      if (!(isArray(mtx) && mtx.length > 0 && mtx[0].length > 1)) {
        return null;
      }
      j = null;
      sortarr = mtx[0].slice(0).sort(function(a, b) {
        return b - a;
      });
      sum = 0;
      i = 1;
      while (i < sortarr.length) {
        sum += sortarr[i];
        i++;
      }
      if (sum === sortarr[0]) {
        j = mtx[0].indexOf(sortarr[0]);
        k = 0;
        while (k < mtx.length) {
          mtx[k].splice(j, 1);
          k++;
        }
      }
      return j;
    };
    transposeMtx = function(mtx) {
      var transpose;
      transpose = [new Array(mtx.length)];
      forEach(mtx, function(row, i) {
        return forEach(row, function(col, j) {
          var _ref;
          if ((_ref = transpose[j]) == null) {
            transpose[j] = [];
          }
          return transpose[j][i] = mtx[i][j];
        });
      });
      return transpose;
    };
    extractTables = function(jsondata) {
      var tables;
      tables = [];
      forEach(jsondata, (function(value, key) {
        var col, j, len, trans;
        if (!value.rows) {
          return;
        }
        this.push({
          fue: "",
          tit: "",
          uni: "",
          tot: [],
          dim: [[], []],
          dat: []
        });
        len = 0;
        forEach(value.rows, (function(row) {
          var k;
          if (!row.values || row.values.length < 2 || (!this.tit && !row.values[0])) {
            return;
          }
          if (!this.uni && this.tit) {
            this.uni = cleanSep(row.values[0]);
          }
          if (!this.tit) {
            this.tit = row.values[0];
          }
          if (len > 1 && !row.values[1] && !this.fue) {
            this.fue = cleanSep(row.values[0]);
          }
          if ("" === trim(row.values[1])) {
            return;
          }
          len++;
          k = 0;
          return forEach(row.values, (function(col, k) {
            if (len === 1) {
              if (k > 0) {
                return this.dim[1].push(trim(col));
              }
            } else {
              if (k === 0) {
                if (trim(col)) {
                  return this.dim[0].push(trim(col));
                }
              } else {
                if (!this.dat[len - 2]) {
                  this.dat[len - 2] = [];
                }
                return this.dat[len - 2].push(col);
              }
            }
          }), this);
        }), tables[tables.length - 1]);
        if (!isIndexTable(tables[tables.length - 1])) {
          return delete tables[tables.length - 1];
        } else {
          j = removeTotal(tables[tables.length - 1].dat);
          if (j !== null) {
            col = tables[tables.length - 1].dim[1].splice(j, 1);
            tables[tables.length - 1].tot[1] = col;
          }
          trans = transposeMtx(tables[tables.length - 1].dat);
          j = removeTotal(trans);
          if (j !== null) {
            tables[tables.length - 1].dat.splice(j, 1);
            col = tables[tables.length - 1].dim[0].splice(j, 1);
            return tables[tables.length - 1].tot[0] = col;
          }
        }
      }), tables);
      return tables.filter(function(x) {
        return x;
      });
    };
    return this[namespace].extractTables = extractTables;
  })();

}).call(this);
